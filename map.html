<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<title>BRC Location</title>
<style>
body,html {
	font-family: verdana;
	font-size: 10pt;
	height: 100%;
	margin: 0;
	padding: 0;
}
input {
	font-size: 10pt;
	text-align: right;
}
#map {
	height: 100%;
}
#brcLoc {
	position: absolute;
	bottom: 54px;
	right: 48px;
}
#llText {
	position: absolute;
	bottom: 24px;
	right: 48px;
}
</style>
<script src="geographiclib.js"></script>
<script src="brc.js"></script>
<script>
/* globals document, window */
/* globals BRC, GeographicLib, google */
"use strict";
function isValidId(s, n)
{
	return s.length <= n && s.match(/^[a-z][_0-9a-z]*$/) !== null;
}
function parseLL(q, v, latIndex, lngIndex)
{
	var m = v.match(/^(-?[0-9]{1,3}(?:\.[0-9]{1,8})?),(-?[0-9]{1,3}(?:\.[0-9]{1,8})?)$/);

	if (m === null) return;

	var lat = parseFloat(m[latIndex]);
	if (lat < -90 || lat > 90) return;

	var lng = parseFloat(m[lngIndex]);
	if (lng < -180 || lng > 180) return;

	q.ll = new google.maps.LatLng(lat, lng);
}
function parseLatLng(q, v) { parseLL(q, v, 1, 2); }
function parseLngLat(q, v) { parseLL(q, v, 2, 1); }
function parseZoom(q, v)
{
	if (v.match(/^[1-9][0-9]?$/) === null) return;

	var zoom = parseInt(v, 10);
	if (zoom < 1 || zoom > 22) return;

	q.zoom = zoom;
}
function parseYear(q, v)
{
	if (v.match(/^20[0-9][0-9]$/) === null) return;

	q.year = v;
}
function parseBRCLocation(q, v)
{
	q.location = v;
}
function parseAzimuth(q, v)
{
	if (v.match(/^-?[0-9]{1,3}(?:\.[0-9]{1,8})?$/) === null) return;

	v = parseFloat(v);
	if (v < -180 || v > 360) return;

	q.azimuth = (v + 360) % 360;
}
function parseManCenter(q, v)
{
	var o = {};
	parseLatLng(o, v);
	if (o.ll)
		q.manCenter = o.ll;
}
function parsePoint3(q, v)
{
	var o = {};
	parseLatLng(o, v);
	if (o.ll)
		q.point3 = o.ll;
	else {
		var m = v.match(/^([0-9]{1,9}(?:\.[0-9]{1,9})?)(ft|km|m|mi)$/);
		if (!m) return;

		var n = parseFloat(m[1]);
		q.point3 = n * {ft: 0.3048, km: 1000, m: 1, mi: 5280 * 0.3048}[m[2]];
	}
}
function parseMapType(q, v)
{
	if (v === 'hybrid' || v === 'roadmap' || v === 'satellite' || v === 'terrain')
		q.mapType = v;
}
function parseQueryString(queryString)
{
	var q = window.location.search;

	if (typeof q !== 'string' || q.charAt(0) !== '?') return;

	var flags = {
		grid: 'drawGrid',
		pentagon: 'drawPentagon',
	};
	var handlers = {
		azi: parseAzimuth,
		azimuth: parseAzimuth,
		man: parseManCenter,
		loc: parseBRCLocation,
		ll: parseLatLng,
		p3: parsePoint3,
		point3: parsePoint3,
		t: parseMapType,
		xy: parseLngLat,
		y: parseYear,
		year: parseYear,
		z: parseZoom,
		zoom: parseZoom,
	};

	for (var s of q.substr(1).split('&'))
	{
		var i = s.indexOf('=');
		if (i < 0 && isValidId(s, 8) && flags[s]) {
			queryString[flags[s]] = true;
			continue;
		}
		if (i < 1 || i === s.length - 1) continue;
		var k = s.substr(0, i);
		var v = s.substr(i + 1);

		if (isValidId(k, 8) && handlers[k])
			handlers[k](queryString, v);
	}
}
function drawPentagon(map, m)
{
	var llArray = [];
	for (var ll of m.Pentagon)
		llArray.push(ll.toGoogle());

	new google.maps.Polygon({
		map: map,
		paths: llArray,
		strokeColor: "#FF0000",
		strokeOpacity: 0.8,
		strokeWeight: 2,
		fillOpacity: 0,
	});
}
function geoDirectGeographicLib(latLong)
{
	var geo = GeographicLib.Geodesic.WGS84;
	var lat1 = latLong.latitude;
	var lon1 = latLong.longitude;

	return function(degrees, meters) {
		var result = geo.Direct(lat1, lon1, degrees, meters);
		return new google.maps.LatLng(result.lat2, result.lon2);
	};
}
function geoDirectGoogleMaps(latLong)
{
	var geo = google.maps.geometry.spherical;
	latLong = latLong.toGoogle();

	return function(degrees, meters) {
		return geo.computeOffset(latLong, meters, degrees);
	};
}
function drawGrid(map, m)
{
	var geoDirect = geoDirectGeographicLib(m.ManCenter);
//	var geoDirect = geoDirectGoogleMaps(m.ManCenter);

	var getLL = function(degrees, meters) {
		return geoDirect((degrees + m.TwelveOClockAzimuth) % 360, meters);
	};

	var streetColor = '#0000FF';
	var streetWeight = 2;
	var midBlockColor = '#FF0000';
	var midBlockWeight = 1;

	var llArray = [];
	var options = {
		clickable: false,
		geodesic: true,
		map: map,
		path: llArray,
		strokeOpacity: 1,
	};

	var radii = m.cachedDistances;
	var numRadii = radii.length;
	for (var i = 0; i < numRadii; ++i)
	{
		var meters = radii[i] * 0.3048;
		var degreeStep = 5 * 180 / (Math.PI * meters); // 5 meters
		var midBlock = (i & 1) === 1;
		var street = (i >> 1) - 1;
		var inWideBefore = false;

		if (midBlock) {
			options.strokeColor = midBlockColor;
			options.strokeWeight = midBlockWeight;
		} else {
			options.strokeColor = streetColor;
			options.strokeWeight = streetWeight;
		}
		for (var degrees = 60; degrees < 300;)
		{
			var angle = degrees > 180 ? 360 - degrees : degrees;
			var inWide = m.inWideBlock(street, angle);
			if (midBlock && (inWide || m.inWideBlock(street + 1, angle)))
			{
				var radialDegrees = i >= 14 ? 7.5 : 15;
				degrees = radialDegrees * Math.floor(degrees / radialDegrees);
				if (llArray.length > 0)
				{
					llArray.push(getLL(degrees, meters));
					new google.maps.Polyline(options);
					llArray.length = 0;
				}
				degrees += radialDegrees;
				continue;
			}
			if (!midBlock && inWide !== inWideBefore)
			{
				var radialDegrees = i >= 14 ? 7.5 : 15;
				degrees = radialDegrees * Math.floor(degrees / radialDegrees);
				var lastPoint = getLL(degrees, meters);
				if (llArray.length > 0)
				{
					llArray.push(lastPoint);
					new google.maps.Polyline(options);
					llArray.length = 0;
				}
				llArray.push(lastPoint);
				if ((inWideBefore = inWide)) {
					options.strokeColor = midBlockColor;
					options.strokeWeight = midBlockWeight;
				} else {
					options.strokeColor = streetColor;
					options.strokeWeight = streetWeight;
				}
				degrees += degreeStep;
				continue;
			}
			llArray.push(getLL(degrees, meters));
			degrees += degreeStep;
		}
		if (llArray.length > 0)
		{
			llArray.push(getLL(300, meters));
			new google.maps.Polyline(options);
			llArray.length = 0;
		}
	}

	var meters0 = radii[0] * 0.3048;
	var metersG = radii[14] * 0.3048;
	var metersL = radii[radii.length - 2] * 0.3048;

	options.strokeColor = streetColor;
	options.strokeWeight = streetWeight;

	var fromG = false;
	for (var degrees = 60; degrees <= 300; degrees += 7.5)
	{
		llArray[0] = getLL(degrees, fromG ? metersG : meters0);
		llArray[1] = getLL(degrees, metersL);
		new google.maps.Polyline(options);
		fromG = !fromG;
	}
}
function init()
{
	BRC.init();

	var queryString = {};
	parseQueryString(queryString);

	var brcMeasurements = queryString.year && BRC.setMeasurements(queryString.year) || BRC.getMeasurements();

	if (typeof queryString.azimuth === "number")
	{
		brcMeasurements = BRC.setMeasurements("custom");
		brcMeasurements.TwelveOClockAzimuth = queryString.azimuth;
	}
	if (queryString.manCenter || queryString.point3 !== undefined)
	{
		brcMeasurements = BRC.getMeasurements("custom");

		if (queryString.manCenter) {
			var gll = queryString.manCenter;
			var ll = brcMeasurements.ManCenter.copy();
			ll.latitude = gll.lat();
			ll.longitude = gll.lng();
			brcMeasurements.ManCenter = ll;
		}
		brcMeasurements.Pentagon = [];

		if (typeof queryString.point3 === "number")
			brcMeasurements.Point3Distance = queryString.point3;
		else if (queryString.point3) {
			var gll = queryString.point3;
			var ll = brcMeasurements.ManCenter.copy();
			ll.latitude = gll.lat();
			ll.longitude = gll.lng();
			brcMeasurements.Pentagon.push(ll);
		}

		brcMeasurements = BRC.setMeasurements("custom");
	}
	if (queryString.location)
	{
		var ll = BRC.getLatLongFromLocation(queryString.location);
		if (ll)
			queryString.ll = ll.toGoogle();
	}

	var currentLL = brcMeasurements.ManCenter.copy();
	var brcLoc = document.getElementById("brcLoc").firstChild;
	var llText = document.getElementById("llText").firstChild;

	var options = {};
	options.center = queryString.ll || currentLL.toGoogle();
	options.disableDoubleClickZoom = true;
	options.mapTypeId = queryString.mapType || google.maps.MapTypeId.SATELLITE;
	options.scrollwheel = false;
	options.zoom = queryString.zoom || 20;

	var map = new google.maps.Map(document.getElementById("map"), options);

	var centerMarker = new google.maps.Marker({
		clickable: false,
		icon: {
			anchor: new google.maps.Point(14, 14),
			size: new google.maps.Size(28, 28),
			url: 'centerIcon.svg'
		},
		map: map,
		position: options.center
	});

	function mapCenterChanged()
	{
		var ll = map.getCenter();
		centerMarker.setPosition(ll);
		currentLL.latitude = ll.lat();
		currentLL.longitude = ll.lng();
		llText.value = ll.toUrlValue();
		brcLoc.value = currentLL.location = BRC.getLocationFromLatLong(currentLL);
		brcLoc.size = brcLoc.value.length > 20 ? 30 : 20;
	}
	mapCenterChanged();
	map.addListener('center_changed', mapCenterChanged);

	if (queryString.drawGrid)
		drawGrid(map, brcMeasurements);
	if (queryString.drawPentagon)
		drawPentagon(map, brcMeasurements);

	var geocoder = new google.maps.Geocoder();

	function geocodeCallback(results, status)
	{
		if (status === "OK") {
			map.setCenter(results[0].geometry.location);
		} else {
			brcLoc.value = currentLL.location;
		}
	}

	brcLoc.addEventListener("change", function() {
		var ll = BRC.getLatLongFromLocation(brcLoc.value);
		if (ll)
			map.setCenter(ll.toGoogle());
		else
			geocoder.geocode({"address": brcLoc.value}, geocodeCallback);
	}, false);
	llText.addEventListener("change", function() {
		var o = {};
		parseLatLng(o, llText.value);
		if (o.ll)
			map.setCenter(o.ll);
		else
			llText.value = map.getCenter().toUrlValue();
	}, false);
}
</script>
</head>
<body>

<div id="map"></div>
<div id="brcLoc"><input type="text" size="20" value="" /></div>
<div id="llText"><input type="text" size="20" value="" /></div>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCQnfgklY64ksLr_JJKE0MdWCPgo0trTZc&libraries=geometry&callback=init" async defer></script>

</body>
</html>
